# D*

## 算法特点

动态路径规划（Dynamic A*），适用于动态环境中的路径规划

A*、Dijkstra 等则适用于静态环境中的路径规划

D* 算法是一种增量路径搜索算法，它允许在搜索过程中不断适应环境的变化。它可以在遇到新障碍物或环境变化时，重新计算最短路径而无需从头开始搜索。

因为D\*算法有上述的特性，所以D\*算法可以使用在“无先验地图信息/先验地图信息不多的环境中的导航”的问题，因为只需要在最开始假装整个地图没有任何障碍，起点到终点的路径就是一条直线，然后再在在线运行时不断使用D\*算法重新规划即可。

- Compare to A*

  A* 算法是从起点向目标点进行搜索，而 D* 算法在预搜索阶段会先从目标点向起点进行搜索。

  

### 适用场景

适用于需要实时路径规划的场景，如自动驾驶、机器人导航等。它可以在动态环境中动态地调整路径以避免障碍物。

## 参考资料

- [wikipedia](https://en.wikipedia.org/wiki/D*)
- [算法动态演示](https://www.youtube.com/watch?v=e_7bSKXHvOI)
- [博客-D*算法超详解](https://blog.csdn.net/rezrezre/article/details/131008284)



## 重要定义

- OpenList

​	维护一个需要进行评估的节点列表

- G 

  表示路径搜索的目标点

  

- C(x,y)

  表示从节点 x 移动到节点 y 的代价

  

- t(x) 节点的状态 state
  - new
  - open
  - closed
  - raise  - 成本高于上次出现在 openlist 中
  - lower - 成本低于上次出现在 openlist 中
  
- h(x)

  表示地图上的点x到达目标点G的代价

-  k(x)

  节点 x 最小的 h(x) 值

- b(x)

  用于记录当前节点x的父节点



- 主要函数

  - Process-State()

    > 计算到目标G的最优路径

  - Modify-Cost(x,y,val)

    >用于改变两个节点（state）之间的开销*C（X,Y）* 并将受影响的节点（state）置于Openlist中
    
  - insert(x,val)

    >修改节点x的状态以及h(x)值和k(x)值

## 算法过程

1. 初始化

   使用 dijkstra算法 从终点开始反向搜索初始地图，得到从地图上所有点到终点的最短距离 h。

   > [为什么初始化搜索阶段不使用搜索效率更高的 A* ?](###1 初始化搜索阶段为什么不使用 A*?)

2. 重规划

   第一步的初始化搜索完成之后，我们可以得到一条从起点到终点的最短路径。此时，机器人就会沿着这一条路径移动，当移动到路径上的某一个点，发现存在障碍物时（初始地图发生变化），就会触发**重规划**操作。
   
   





















## Hint

### 1 初始化搜索阶段为什么不使用 A*?

这是D\*的一个核心问题。其实也可以在第一次搜索中加入启发函数，让第一次快一点，但是D\*的核心是保证在全过程中，出现新发现的障碍物时也能很快地找到解，所以第一次搜索的范围其实尽可能的大会好一点。
如果在第一次搜索加入启发函数，确实第一次搜索会快很多，因为搜索范围小了。但是在后面发现新障碍物的时候，因为第一次的搜索范围比较小，很可能这个新障碍物导致的重新搜索，需要重新搜索一些第一次没搜索到的空间，因此这些点依然会被加入到搜索队列中。
一言概之就是说，启发式搜索减少的第一次搜索的点，终归会在后面的搜索中加入到搜索队列中，出来混迟早是要还的，所以实际上并不能很好地提高效率。
这样做可能让整体来说的效率变高，但是方法是减少第一次的搜索范围，而增加后续的搜索范围，而D*因为更多强调实时性，而第一次搜索是可以离线运行，但后续的搜索一定是在线运行的，增加后续的搜索范围会使实时性降低，这反而是不能接受的，因此尽管整体（也即第一次+后续搜索）的效率提升，但后续搜索的效率降低，得不偿失。
